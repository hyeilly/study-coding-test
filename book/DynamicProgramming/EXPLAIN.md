### 다이나믹 프로그래밍으로 해결 가능한 문제
#### 피보나치 수열
- 두 항의 합을 현재 항으로 설정하는 특징
- 점화식(인접한 항들 사이 관계식)을 사용해 항이 이어지는 형태를 간결하게 표현
- 수열 an => 점화식 An+2 = f(An+1, An) = An+1 + An => 인접 3항간 점화식
- 등치수열 점화식 = An+1 = f(An) = An + 1
- 피보나치 수열에서는 첫 번째 항과 두 번째 항의 값이 모두 1 => An = An-1 + An+2, A1 = 1, A2 = 1
##### 해석
  - n번째 피보나치 수 = (n - 1)번째 피보나치 수 + (n - 2)번째 피보나치 수
  - 단, 1번째 피보나치 수 = 1, 2번째 피보나치 수 = 1
##### 시간 복잡도
- O(2^n) 지수 시간 소요. 
- f(n)에서 n이 커지면 커질수록 반복해서 동일한 함수가 호출
- 다이나믹 프로그래밍을 사용해 효율적으로 계산 가능
  1. 큰 문제를 작은 문제로 나눌 수 있음
  2. 작은 문제에서 정답은 그것을 포함하는 큰 문제에서도 동일

#### 메모이제이션 기법
- 다이나믹 프로그래밍 구현 중 한 종류
- 한 번 구한 결과를 메모리 공간에 메모. 
- 같은 식을 다시 호출하면 메모한 결과 그대로 가져오기
- 메모이제이션은 값을 저장하는 방법이므로 '캐싱'이라고도 함 
- 단순히 한 번 구한 정보를 리스트에 저장하는 것
- 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때 이미 구한 정답 그대로 리스트에서 가져오기

#### 다이나믹 프로그래밍이란
- 큰 문제를 작게 나누고
- 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결
- 큰 문제를 작게 나누는 방법 => 퀵 정렬
  - 정렬할 리스트 분할하며 전체적으로 정렬 = **분할 정복 알고리즘**
- 시간 복잡도 O(N)
##### Top-Down 방식(=Memoization =하향식)
- 큰 문제를 해결하기 위해 작은 문제 해결 (**Call-Function.py**)
- 메모이제이션 : 이전 계산된 결과를 일시적으로 기록
  - 때에 따라서 다른 자료형(ex.dict자료형)이용
    - 연속적이지 않은 경우 유용
    - A0 ~ An-1 모두가 아닌 일부의 작은 문제에 대한 해답 필요할 때
##### Bottom-Up 방식(=상향식)
- 단순 반복문을 이용해 소스코드 작성하는 경우 작은 문제부터 답 도출
- 저장용 리스트는 'DP 테이블'
##### 다이다믹 프로그래밍 유형 파악
- 특정 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 오래 걸리면 다이나믹 프로그래밍 적용
- 일단 단순 재귀함수로 프로그래밍 작성 후 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있다면 코드 개선
- 재귀함수 이용하는 TopDown방식 보다는 **BottomUp 방식**으로 구현
  - 시스템상 재귀 함수의 스택 크기 한정되어 있을 수 있음 
- 재귀함수 깊이 관련 오류 발생 시
  - sys 라이브러리에 포함된 setrecursionlimit()함수 호출 
