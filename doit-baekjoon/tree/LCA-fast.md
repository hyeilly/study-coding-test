# 최소 공통 조상 - 빠르게 구하기
- 서로의 깊이를 맞춰 주거나
- 같아지는 노드를 찾을 때 기존에 한 단계씩 올려주는 방식
- **2^k**씩 올라가 비교하는 방식
- 자신의 부모 노드만 저장해놓던 방식에서 2^k번째 위치의 부모 노드까지 저장해두어야함

# 방법
1. 부모 노드 저장 배열 만들기
- 부모 노드 배열의 정의
P\[K][N] = N번 노드의 2^k 번째 부모의 노드 번호
- 부모 노드 배열의 **점화식**
P\[K][N] = P\[K - 1]\[P\[K - 1][N]]
ex) P\[2][10] => 10번 노드의 2^2번째 부모 노드
- P\[1]\[P\[1][10]] = 10번 노드의 2^1번째 부모 노드 의 2 ^1번째 부모 노드
- 점화식에서 N의 2^k번째 부모 노드 = N의 2^k-1번째 부모 노드의 2^k-1번째 부모 노드라는 의미
- 배열에서 K는 '트리의 깊이 > 2^k'를 만족하는 최댓값
ex)
- 초기 세팅값 k가 0일때. DFS, BFS로 값 채우기

2. 선택된 두 노드의 깊이를 맞추기
- 기존에 한 단계씩 맞첬던 겊이를 2^k 단위로 넘어가면서 맞춤
3. 최소 공통 조상 찾기
- 공통 조상 역시 2^k 단위로 점프하면서 맞춤. 
- K값 1씩 감소하면서 P 배열을 이용. 최초로 두 노드의 부모 노드가 달라짐
- 값이 다를 때 점프. P\[1][14] = 10 != \[P1][15] = 11
- K가 0이 될 때까지 반복. 반복문 종료된 후 이동한 2개의 노드가 같은 노드라면 해당 노드
- 다른 노드라면 바로 위의 부모 노드가 최소 공통 조상.

# 문제 분석
- 기존 LCA 문제보다 노드의 개수와 질의의 개수가 매우 커짐
- 제곱수 형태를 이용한 빠르게 최소 공통 조상 구하기 방식으로 구현

# 문제 풀이
1. 인접리스트 트리로 데이터 구현
2. 탐색 알고리즘(DFS, BFS) 이용해 각 노드의 깊이를 구함
- 바로 위 부모 노드도 구하기
3. 점화식을 이용해 Parent 배열(부모 노드 배열) 구함
4. 깊이가 큰 노드는 Parent 배열을 이용해 2^k만큼 빠르게 이동시켜 깊이를 맞춤
- 깊이가 2만큼 차이(2^1)가 나므로 15번 노드를 15의 2^1번째 부모 노드인 5로 변경해 깊이를 맞춤
- 한 칸씩 오르는 것이 아닌 2의 제곱수로 빠르게 올라감
5. 부모 노드로 올라가면서 최소 공통 조상을 찾음. 
- Parent 배열을 이용해 2^k만큼 넘어가면서 찾는 것이 핵심
- k는 depth 의 최댓값에서 1씩 감소