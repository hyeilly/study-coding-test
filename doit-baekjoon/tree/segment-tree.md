# 세그먼트 트리
- 주어진 데이터의 구간 합과 **데이터 업데이트**를 빠르게 수행하기 위해 고안
- 더 큰 범위는 인덱스 트리
- 합배열 \[3, 5, 4, 2, 3, 7, 4] => \[3, 8, 12, 14, 17, 24, 28]

# 세그먼트 트리 핵심 이론
- 구간 합, 최대/최소 구하기
- 구현단계 : 트리 초기화하기, 질의값 구하기(구간 합 또는 최대/최소), 데이터 업데이트 하기

## 1. 트리 초기화하기
- 리프 노드의 개수가 데이터의 개수(N) 이상이 되도록 **트리 배열** (리프 노드가 원본 데이터 배열)
  - 구하는 방법 : 2^k >= N 을 만족하는 k 값의 최솟값 구한 후 2^k * 2를 트리 배열의 크기로 정의
    - 트리의 전체 개수. 각각의 노드 개수 다 합친거 만큼 인덱스 트리를 1차원 배열로 나타내기 위해
- 샘플 데이터 : {5, 8, 4, 3, 7, 2, 1, 6}
  1. 2^k >= 8 에 맞는 k = 1, 2, 3
  2. 트리 배열의 크기 = 2^k * 2 = 2^3 * 2 = 18
  3. k의 값이 3이면 start index= 8(2^k 를 시작 인덱스로 취급)
  4. 샘플 데이터는 리프 노드를 제외한 나머지 노드의 값을 채움. (2^k - 1부터 1번쪽으로 채움)
  5. 자식 노드의 인덱스는 이진 트리 형식이기 때문에 2N, 2N + 1
  6. A = [x, 0, 0, 0, 0, 0, 0, 0, 5, 8, 4, 3, 7, 2, 1, 6]
  7. 구간합 A[N] = A[2N] + A[2N + 1]
     - A[15] = 6 => 15/2 = 7 => A[7] = 6 이고 A[14] = 1 => 14/2 = 7 => A[7] = 1 두개 더하기(=7은 14, 15의 구간합)
     - 결과A = [x, 36, 20, 16, 13, 7, 9, 7, 5, 8, 4, 3, 7, 2, 1, 6]
  8. 구간의 최대 값 A[N] = max(A[2N], A[2N + 1])
     - [x, 8, 8, 7, 8, 4, 7, 6, 5, 8, 4, 3, 7, 2, 1, 6]
  9. 구간의 최소 값 A[N] = min(A[2N], A[2N + 1])
     - [x, 1, 3, 1, 5, 3, 2, 1, 5, 8, 4, 3, 7, 2, 1, 6]

## 2. 질의값 구하기
- 주어진 질의 인덱스를 세그먼트 트리의 리프 노드에 해당하는 인덱스로 변경
### 질의 인덱스를 세그먼트 트리 인덱스로 변경하는 방법
**세그먼트 트리 index = 주어진 질의 index + 2^k - 1**
### 질의값 구하는 과정
1. start_index % 2 == 1 일때 해당 노드를 선택
2. end_index % 2 == 0 일때 해당 노드를 선택
===노드를 선택했다=> 해당 노드의 부모가 나타내는 범위가 질의 범위 넘어가므로 해당 노드를 질의 값에 영향 미치는 독립 노드로 선택===
3. start_index depth 변경 : start_index = (start_index + 1) / 2 연산을 실행
4. end_index depth 변경 : end_index = (end_index - 1) / 2 연산을 실행
===질의 범위에 해당하는 부모 노드로 이동하기 이ㅜ해 인덱스 연산 수행===
5. 1 ~ 4 반복하다가 end_index < start_index가 되면 종료
### 질의에 해당하는 노드 선택하는 방법
- 구간 합, 최댓값 구하기, 최솟값 구하기 모두 동일하며 선택된 노드들에 관해 마지막에 연산하는 방식만 다름
- 구간 합 : 선택된 노드를 모두 더함
- 최댓값 구하기 : 선택된 노드 중 MAX 값을 선택해 출력
- 최솟값 구하기 : 선택된 노드 중 MIN 값을 선택해 출력

#### 예시: 2 ~ 6 사이 구간 합, 최댓값, 최솟값 구하기
1. 리프 노드의 인덱스로 변경
start_index = 2 + 7 = 9
end_index = 6 + 7 = 13
2. 부모 노드로 이동
start_index % 2 = 9 % 2 = 1 // 노드 선택 (1이 나오면 오른쪽에 있는 자식노드 , 0이 나오면 왼쪽에 있는 자식노드)
end_index % 2 = 13 % 2 = 1 // 노드 미선택 (1이 나오면 오른쪽에 있는 자식노드 , 0이 나오면 왼쪽에 있는 자식노드)
start_index = (start_index + 1) / 2 = 10 / 2 = 5
end_index = (end_index - 1) / 2 = 12 / 2 = 6
3. 한번 더 부모 노드로 이동
start_index % 2 = 5 % 2 = 1 // 노드 선택
end_index % 2 = 6 % 2 = 0 // 노드 선택
start_index = (start_index + 1) / 2 = 6 / 2 = 3
end_index = (end_index - 1) / 2 = 5 / 2 = 2
=> 선택된 노드의 합인 8 + 9 + 7 = 24

## 3. 데이터 업데이트 하기
- 구간 합 : 원래 데이터와 변경 데이터 차이만큼 부모 노드로 올라가면서 변경
- 최댓값 찾기 : 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해서 더 큰 값으로 업데이트. 업데이트 일어나지 않으면 종료
- 최솟값 찾기 : 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해서 더 작은 값으로 업데이트. 업데이트 일어나지 않으면 종료
- ex) 5번 데이터 값을 7에서 10으로 업데이트 => 5 + 7 = 12

## 정리
### 세그먼트 트리 단계
1. 트리 초기화 하기 
1-1. 크기 정하기 = 2^k >= N = 2^k * 2 
1-2. 부모 노드 값 채우기
2. 질의값 구하기
2-1. 질의 index를 트리에 맞게 변경
2-2. start % 2 = 1이 나오면 선택, end % 2 = 0이 나오면 선택
2-3. 독립노드인 경우 점프 해주기 위해. 
start = (start + 1) / 2
end = (end - 1) / 2
2-4. start >= end 이면 끝나고 그때까지 선택된 값들을 가지고 판단
3. 데이터 업데이트
트리의 특성을 살려
이진트리가 부모로 갈때 /2 하며 각 조건에 맞게 업데이트
조건 - 부분합 || 최대 || 최소
데이터 업데이트를 빠르게 할 수 있으므로 세그먼트 트리를 사용하는 것